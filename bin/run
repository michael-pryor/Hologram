#!/bin/sh -e
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

if [ ! -d "$LOG_DIR" ]; then
   echo "FAIL: LOG_DIR environment variable not set, should be in .bashrc"
   exit 1
fi

if [ "$#" -lt 1 ]; then
    echo "Incorrect number of arguments:"
    echo "1. Entity name, so we know what file to source."
    echo "2. Action, start/stop etc"
fi

ACTION="$1"
ENTITY="$2"
SILENCE_ECHO="$3"

echoEx() {
   if [ -z ${SILENCE_ECHO} ]; then
      echo $@
   fi
}

ENTITY_DIR="${DIR}/apps"
ENTITY_FILE="${ENTITY_DIR}/${ENTITY}.sh"
if [ ! -f ${ENTITY_FILE} ]; then
    echo "Component ${ENTITY} not found (check ${ENTITY_DIR}, we looked for ${ENTITY_FILE})"
    exit 1
fi

source "${ENTITY_FILE}"
if [ -z ${JOB_NAME} ]; then
   echo "Buggy app file [${ENTITY_FILE}], missing JOB_NAME variable to tell us what expression to pass to pkill when we terminate the app"
   exit 1
fi

if [ -z "${JOB}" ]; then
   echo "Buggy app file [${ENTITY_FILE}], missing JOB variable to tell us what to run when starting the app"
   exit 1
fi

if [ -z "${LOG_DIR}" ]; then
   echo "LOG_DIR variable not set, suggest setting it in ~/.bashrc, we need to know where we should store log files"
   exit 1
fi

if [ ! -d "${LOG_DIR}" ]; then
   echo "LOG_DIR directory not found (${LOG_DIR})"
   exit 1
fi

echoPrefix() {
  echoEx "[${1} - ${ENTITY} ($JOB_NAME)] -"
}

LOG_FILE="${LOG_DIR}/${JOB_NAME}_${ENTITY}.log"

callSelf() {
   SILENCE_ECHO_TO_PASS="${2}"
   if [ -z ${SILENCE_ECHO_TO_PASS} ]; then
       SILENCE_ECHO_TO_PASS=$SILENCE_ECHO
   fi

   "$0" "${1}" "${ENTITY}" "${SILENCE_ECHO_TO_PASS}"
}

isRunning() { 
   pgrep -f "${JOB}" > /dev/null
}

pid() {
   pgrep -f "${JOB}"
}

processUpTime() {
  PID=${1}
  
  # Get up time.
  upTime="$(ps -p "${PID}" -o etime=)"
  
  # Strip white space.
  upTime=$(echoEx -e "${upTime}" | tr -d '[[:space:]]')

  echoEx ${upTime}  
}

case $ACTION in
stop)
   if ! isRunning
   then
       echoEx "$(echoPrefix STOP) not running, no action taken"
       exit 0
   fi
 
   pkill -9 -f "${JOB}"
   echoEx "$(echoPrefix STOP) success"
;;

start)
   if isRunning
   then
       echoEx "$(echoPrefix START) already running, no action taken"
       exit 0
   fi

   ${JOB} >> "${LOG_FILE}" 2>&1 &
   echoEx "$(echoPrefix START) started]"
;;

startl)
   callSelf start
   callSelf lesslog
;;

restart)
   callSelf stop
   callSelf start
;;

lesslog)
   less "${LOG_FILE}"
;;

state)
   if isRunning
    then
       pidVal="$(pid)"
       echoEx "$(echoPrefix STATE) is RUNNING (pid = ${pidVal}, uptime = $(processUpTime ${pidVal}))"
    else
       echoEx "$(echoPrefix STATE) is DOWN"
    fi
;;

audit_regular)
   AUDIT_REGULAR_LOCK="${DIR}/${JOB_NAME}_${ENTITY}.restart_lock"

   if ! isRunning
   then
      if [ ! -f "$AUDIT_REGULAR_LOCK" ] ; then
          echoEx "$(echoPrefix AUDIT) is NOT RUNNING! Attempting to restart."
          echoEx "Note that you will not receive further email notification about the state of this job, or about further restarts. Clear the lock at [$AUDIT_REGULAR_LOCK] to re-enable email notification for this job"
	  echo "Delete this lock to re-enable email on the service ${ENTITY} (${JOB_NAME})" > ${AUDIT_REGULAR_LOCK}
          callSelf restart
      else
          # Don't echo anything, since anything we echo gets emailed.
          callSelf restart 1
      fi
   fi
;;

*)
   echoEx FAIL: available commands are: stop, start, restart, lesslog.
;;
esac
